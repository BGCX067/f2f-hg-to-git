///////////////////////////////////////////////////////////////////////////////
//
// Generated by Impulse CoDeveloper
// Impulse C is Copyright(c) 2003-2007 Impulse Accelerated Technologies, Inc.
// 
// FPGA_hw.c: includes the hardware process and configuration
// function.
//
// See additional comments in FPGA.h.
//

#include "co.h"
#include "cosim_log.h"
#include "FPGA.h"
#include "arithmetic.h"
#include "types.h"

// Software process declarations (see FPGA_sw.c)
extern void Producer(co_stream input);
extern void Consumer(co_stream output);
//
// This is the hardware process.
// 
void fpga(co_stream input, co_stream output)
{
    FloatType dato_entrada;

    FloatType firstx[CANT_COORD_POR_ESTRUCTURA];
    FloatType firsty[CANT_COORD_POR_ESTRUCTURA];
    FloatType firstz[CANT_COORD_POR_ESTRUCTURA];
    FloatType secondx[CANT_COORD_POR_ESTRUCTURA];
    FloatType secondy[CANT_COORD_POR_ESTRUCTURA];
    FloatType secondz[CANT_COORD_POR_ESTRUCTURA];
    FloatType dato_salida;
    FloatType sumatoria;

    int i;
    int j;
    int k;
    int l;

    co_array_config(firstx, co_kind, "dualsync");
    co_array_config(firsty, co_kind, "dualsync");
    co_array_config(firstz, co_kind, "dualsync");
    co_array_config(secondx, co_kind, "dualsync");
    co_array_config(secondy, co_kind, "dualsync");
    co_array_config(secondz, co_kind, "dualsync");

    IF_SIM(int samplesread; int sampleswritten;)

    IF_SIM(cosim_logwindow log;)
    IF_SIM(log = cosim_logwindow_create("fpga");)

    do 
    {
        IF_SIM(samplesread=0; sampleswritten=0;)
	
        co_stream_open(input, O_RDONLY, INT_TYPE(STREAMWIDTH));
        co_stream_open(output, O_WRONLY, INT_TYPE(STREAMWIDTH));

        for (i = 0; i < CANT_COORD_POR_ESTRUCTURA; ++i)
        {
            co_stream_read(input, &dato_entrada, sizeof(FloatType));
            firstx[i] = dato_entrada;
            co_stream_read(input, &dato_entrada, sizeof(FloatType));
            firsty[i] = dato_entrada;
            co_stream_read(input, &dato_entrada, sizeof(FloatType));
            firstz[i] = dato_entrada;
        }

        for (i = 0; i < CANT_COORD_POR_ESTRUCTURA; ++i)
        {
            co_stream_read(input, &dato_entrada, sizeof(FloatType));
            secondx[i] = dato_entrada;
            co_stream_read(input, &dato_entrada, sizeof(FloatType));
            secondy[i] = dato_entrada;
            co_stream_read(input, &dato_entrada, sizeof(FloatType));
            secondz[i] = dato_entrada;
        }

        // SE APLICA LA LOGICA DE CALCULO //
        sumatoria = 0;
        for (k = 0; k < CANT_COORD_POR_ESTRUCTURA; ++k)
        {
            #pragma CO PIPELINE
            #pragma CO SET STAGEDELAY 64

            assign_add(sumatoria, add3(square(sub(firstx[k], secondx[k])),
                                       square(sub(firsty[k], secondy[k])),
                                       square(sub(firstz[k], secondz[k]))));
        }

        dato_salida = divide(sumatoria, to_current(CANT_COORD_POR_ESTRUCTURA));
        /////////////////////////////////*/

        co_stream_write(output, &dato_salida, sizeof(FloatType));
        IF_SIM(sampleswritten++;)

        co_stream_close(input);
        co_stream_close(output);
        IF_SIM(cosim_logwindow_fwrite(log, "Closing filter process, samples read: %d, samples written: %d\n", samplesread, sampleswritten);)
	
        IF_SIM(break;)

    } 
    while(1);
}

//
// Impulse C configuration function
//
void config_FPGA(void *arg)
{
    co_stream input;
    co_stream output;

    co_process fpga_process;
    co_process producer_process;
    co_process consumer_process;

    IF_SIM(cosim_logwindow_init();)

    input = co_stream_create("input", INT_TYPE(STREAMWIDTH), STREAMDEPTH);
    output = co_stream_create("output", INT_TYPE(STREAMWIDTH), STREAMDEPTH);

    producer_process = co_process_create("Producer", (co_function)Producer, 1, input);

    fpga_process = co_process_create("fpga", (co_function)fpga, 2, input, output);

    consumer_process = co_process_create("Consumer",(co_function)Consumer, 1, output);

    co_process_config(fpga_process, co_loc, "pe0");  
}

co_architecture co_initialize(int param)
{
    return(co_architecture_create("FPGA_arch","Generic",config_FPGA,(void *)param));
}
